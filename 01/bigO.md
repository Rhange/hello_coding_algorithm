# Big O

- Big O notation은 최악의 상황에 대한 결과
- O(log n), ex) 이진 탐색
- O(n), ex) 단순 탐색
- O(n \* log n), ex) 퀵 정렬과 같이 빠른 정렬 알고리즘
- O(n^2), ex) 선택 정렬과 같이 느린 정렬 알고리즘
- O(n!), ex) 외판원 문제, 정말 느린 알고리즘

- 오메가는 최선의 상황에 대한 실행시간을 나타냄. 즉, 운 좋을 경우
- 세타는 O와 오메가의 실행시간이 서로 같을 경우를 나타냄.

## 실행 시간

- Simple Search => Linear time
- Binary Search => Logarithmic time
- 선형 시간과 로그 시간은 한 상황에 비추어 단순히 배수로 비교할 수 없다. 서로 증가하는 비율이 다르기 때문.
- 100개의 데이터에서 단순 탐색과 이진 탐색의 차이는 15배이지만, 10억개가 있다면 그 차이는 3천 3백만배나 된다.
- 리스트의 크기가 증가할 때 어떻게 증가하는지를 파악할 필요가 있다. 빅오 표기법을 사용하는 이유가 바로 이것 때문이다.
- 빅오 표기법은 알고리즘이 얼마나 빠른지를 말해준다.
- 빅오 표기법은 계산 속도를 시간 단위로 세지 않는다. **연산 횟수**를 비교한다.

## Simple Search

- O(n)

## Binary Search

- O(log n)

### 정리

- 알고리즘의 속도는 '시간'이 아니라 **'연산 횟수'**가 *"어떻게 증가하는지"*로 측정
- 데이터의 크기가 늘어날 때, 알고리즘의 실행 속도가 얼마나 증가하는지 알 수 있음
- 알고리즘의 실행 시간은 빅오 표기법으로 나타낸다.

## 연습문제

1. 128개의 이름이 정렬되어 있는 리스트. 이진 탐색으로 이름을 찾을 때 필요한 최대의 추측 횟수는?

   - log(128) => 7

2. 리스트의 크기가 두 배가 된다면 최대 추측 횟수는?

   - log(256) => 8

3. 다음 각각의 실행 시간을 빅오 표기법으로 표시하세요.

   - 어떤 사람의 이름을 알고 있다. 전화번호부에서 이 사람의 전화번호를 찾고 싶다.

     - O(log n)

   - 전화번호를 알고 있다. 전화번호부에서 이 전화번호를 가진 사람의 이름을 찾고 싶다.

     - O(n)
       <!-- 정렬이 이름순으로 되어 있어서 -->

   - 전화번호부에 있는 모든 사람의 전화번호를 알고 싶다.

     - O(n)

   - 알파벳 A로 시작하는 사람들의 전화번호를 알고 싶다.

     - O(n/26): X, O(n): O
     - 상수는 무시하기 때문에
