# What to study more

## 01 Trees

### Binary Search Trees (이진 탐색 트리) 자료구조

- 평균적으로 O(log n) 시간, 최악의 경우 O(n) 시간

### 배열과 이진 탐색 트리 비교

- 배열
  - 탐색: O(log n)
  - 삽입: O(n)
  - 삭제: O(n)
- 이진 탐색 트리
  - 탐색: O(log n)
  - 삽입: O(log n)
  - 삭제: O(log n)

### 이진 탐색 트리의 단점

1. 임의 접근(random access) 불가능
2. 평균적인 성능이 트리가 얼마나 균형 잡혀있는가에 따라 다르다.

### 여러가지 유용한 트리 유형

1. Red-Black Trees

   - 스스로 균형을 맞추는 특별한 이진 탐색 트리

2. B-Trees

   - 데이터베이스에서 데이터를 저장할 때 흔히 사용

3. Heaps

4. Splay Trees

## 02 Inverted index(역 인덱스)

- 검색 엔진에서 웹 페이지를 보여줄 때, 해시 테이블을 사용하여 보여줄 웹 페이지를 선택할 수 있음.

## 03 Fourier transform (퓨리에 변환)

- "Fourier transform을 사용하면 스무디(smoothie)가 무슨 성분으로 구성되어 있는지 알아내는 것처럼 하나의 노래를 여러 개의 개별적인 주파수들로 분리 할 수 있다." - Better Explained
- 노래를 주파수별로 분리해서 듣고 싶은 주파수만 들을 수도 있다. 중저음 영역을 확대하고 고음 영역을 가릴 수도 있다.
- Fourier transform은 신호를 처리하는데 아주 뛰어나다. 음악을 압축하는 데도 사용할 수 있다.
- 음향 파일을 개별 음파로 분리한 다음 각 음파가 전체 노래에 어느 정도 기여하는지를 계산해서 별로 중요하지 않은 음파를 제거한다.
- MP3 포맷이 이런 방식으로 동작한다.
- JPG 포맷도 압축 포맷의 일종인데 같은 방식으로 동작한다.
- 지진이 발생하는 것을 예측할 수 있고, DNA 분석하는 데도 Fourier transform이 사용된다.
- Shazam(음악을 이식해서 제목 등을 알려주는 앱)과 같이 지금 나오는 음악이 어떤 음악인지 알아 맞추는 앱을 만들 때도 사용할 수 있다.

## 04 병렬 알고리즘(Parallel Algorithm)

- 옛날에는 컴퓨터가 점점 빨라지기만 해서 알고리즘을 더 빠르게 동작하도록 만들려면 기다려서 컴퓨터 자체가 빨라지면 되었다.
- 하지만 그런 시대는 지나고 이제는 여러 개의 코어가 탑재되었다.
- 이제는 알고리즘을 더 빨리 동작시키고 싶다면 여러 개의 코어에서 동시에 돌아가도록 병렬 실행을 하면 된다.
- 예를 들어 정렬 알고리즘은 최고 O(n \* log n) 실행 속도를 가질 수 있다.
- O(n) 시간에 정렬을 할 수 없다는 것은 잘 알려진 사실이다. 하지만 병렬화된 퀵 정렬 알고리즘을 사용하면 O(n) 시간에 배열을 정렬할 수 있다.
- 벙렬 알고리즘은 설계하기 어렵고, 올바르게 동작하는지, 어느 정도의 속도 향상을 얻을 수 있는지 정확하게 파악하기도 어렵다.
- 한 가지 확실한 것은 속도 향상이 선형적이지 않다는 것이다. 그러므로 한 개의 코어가 아니라 두 개의 코어에서 알고리즘을 돌린다고 하더라도 마법처럼 두 배로 빨라지지는 않는다. 그 이유는 아래와 같다.

  1. 병렬화를 관리하는 데 들어가는 부담

     - 만약 1,000개의 항목을 가지는 배열을 정렬한다고 할 때, 이 작업을 어떻게 두 개의 코어가 처리하도록 나눌까? 각각의 코어가 500개의 항목을 정렬한 다음 정렬된 두 개의 배열을 하나의 큰 정렬 배열로 합칠 건가? **두 배열을 합치는 데도 시간이 걸린다!**

  2. 로드 밸런싱(load balancing)
     - 여러분이 10개의 작업을 해야 해서 두 개의 코어에 5개씩 작업을 나누어 주었다. 그런데 A 코어는 쉬운 일만 받아서 10초 내에 끝내고, B 코어는 어려운 일만 받아서 모든 작업을 하는 데 1분이 걸렸다. 이렇게 되면 50초 동안 B 코어 혼자 열심히 일을 하고 A 코어는 놀기만 한다. 두 개의 코어에 일을 균등하게 배분하려면 어떻게 해야 할까?

## 05 Map-Reduce (MR, 맵 리듀스)

- 분산 알고리즘(distributed algorithm): 점점 인기가 높아지고 있는 특별한 병렬 알고리즘
- 만약 코어가 두 개나 네 개 정도 필요하다면 노트북에서 병렬 알고리즘을 돌려도 된다.
- 하지만 만약 수백 개의 코어가 필요하다면? 그럼 여러 대의 컴퓨터에서 돌아가는 분산 알고리즘을 만들어야 된다.
- 맵리듀스 알고리즘(MapReduce Algorithm)은 인기 있는 분산 알고리즘이다.
- 아파치 하둡(Apache Hadoop)과 같은 오픈 소스 툴을 통해 맵리듀스 알고리즘을 사용할 수 있다.

### 분산 알고리즘이 유용한 이유는?

- 만약 수십억 혹은 수조 단위의 레코드를 가진 테이블에 대해 아주 복잡한 SQL 쿼리를 돌려야 한다고 가정해보자.
- MySQL에서는 불가능하다!
- 레코드 수가 수십억 개만 되어도 힘들어한다.
- 이럴 때는 하둡에서 맵리듀스를 사용하는게 좋다.
- 또 다른 예로 많은 일련의 작업을 수행해야 한다고 생각해보자.
- 실행 시간이 10초 정도 소요되는 작업을 총 100만 개 처리해야 한다. 만약 한 대의 컴퓨터에서 작업한다면 몇 달이 걸릴지 모른다!
- 하지만 100대의 컴퓨터에서 실행한다면 며칠이면 된다.
- 분산 알고리즘은 이렇게 많은 작업을 하면서 실행 시간을 단축시키고 싶을 때 유용하다.
- 맵리듀스는 맵 함수(map function)과 리듀스 함수(reduce function)라는 두 개의 간단한 개념을 이용하여 만들어졌다.

## 06 블룸 필터와 하이퍼로그로그

### Bloom filter

- 확률론적 자료구조
- 거의 대부분 옳은 답을 주긴 하지만, 항상 그렇지는 않다.
- 해시 테이블이 항상 정확한 답을 주는 것과는 다르게 블룸 필터는 매번 옳은 답을 주지는 않는다.

  1. 블룸 필터는 틀린 답을 맞다고 할 수도 있다. 예를 들어 구글 서비스의 경우, "이 사이트는 **이미 크롤링했습니다.**"라는 답을 얻었더라도 사실 크롤링하지 않았던 사이트일 수도 있다는 말이다.
  2. 하지만 맞는 답을 틀리다고 하지는 않는다. 즉, "이 사이트는 **크롤링하지 않았습니다.**"라는 답이 나왔다면 진짜 크롤링한 적이 없다는 뜻이다.

- 블룸 필터는 저장 공간을 아주 적게 차지하기 때문에 획기적이다.
- 해시 테이블이라면 모든 웹 주소를 저장해야 하지만 블룸 필터는 그렇게 하지 않는다.
- 항상 정답이 필요한 상황이 아니라면 블룸 필터가 아주 유용하다.

### 하이퍼로그로그(HyperLogLog)

- 만약 구글에서 사용자의 검색내역 중 특정한 검색에 대한 횟수를 세고 싶다거나, 아마존에서 오늘 사용자가 특정 상품을 몇 번 봤는지 알고 싶다고 생각해보자.
- 이 문제를 풀기 위해서 엄청나게 많은 저장 공간이 필요하다.
- 구글이라면 모든 검색에 대해 로그를 남겨야 한다.
- 사용자가 무언가를 검색할 때마다 그 항목이 있는지 확인한 후에 만약 없다면 로그에 추가해야 한다.
- 단 하루뿐이라고 해도 로그의 양이 엄청나게 많을 것이다.

- 하이퍼로그로그는 집합에 있는 똑같은 원소의 개수를 **대략적**으로 셀 수 있다.
- 정확한 값을 주지는 않지만 정확한 값을 주기 위해 필요한 메모리의 아주 일부분만 사용해서 꽤 근사한 값을 줄 수 있다.
- 만약 근사값이라도 괜찮은 경우라면 이런 확률론적 방법을 생각해보라!

## 07 SHA Algorithm

- 해시 함수는 좋은 분포(distribution) 특성을 가져야 한다.
- SHA(Secure Hash Algorithm, 보안 해시 알고리즘) 함수도 해시 함수의 일종이다.
- SHA 함수는 문자열을 받아 그 문자열에 대한 해시값을 반환한다.
- ex) "hello" => 2cf24db...
- SHA는 해시 함수이지만 출력된 해시값은 숫자가 아니라 짧은 문자열이다.
- 해시 테이블용 해시 함수는 배열 인덱스, 즉 숫자를 출력하지만 SHA는 문자열을 받아서 문자열을 출력한다.
  - "algorithm" => b1eb2ec...
  - "password" => 5e88489

1. 두 파일이 같은지 알아보는 데도 SHA를 사용할 수 있다. 특히 파일 크기가 클 때 유용하다.

   - 예를 들어, 4GB 크기의 파일이 있는데 친구가 가지고 있는 파일과 같은 파일인지 확인하고 싶다. 이때 이를 확인하기 위해 굳이 파일 전체를 이메일에 첨부해서 친구에게 보낼 필요는 없다.
   - 대신에 두 파일에 대한 SHA 해시값을 비교하면 된다.

2. 패스워드 확인

   - SHA는 원래 문자열을 밝히지 않고 두 문자열을 비교할 때도 유용하다.
   - 예를 들어, Gmail 서비스가 해킹을 당해서 해커가 패스워드를 알아낼 수 있을까? No!
   - 구글은 패스워드 자체를 저장해 놓지 않는다. 패스워드에 대한 SHA 해시값만 저장해 놓는다.
   - 여러분이 패스워드를 입력하면 구글에서는 그 문자열에 대한 해시값을 계산해서 데이터베이스에 저장해 놓았던 패스워드의 해시값과 비교한다.
   - SHA는 **단방향** 해시이다. 문자열에서 해시값을 얻을 수는 있지만, 해시값에서 문자열을 알 수는 없다.
   - 즉, 해커가 Gmail을 해킹해서 SHA 해시값을 본다고 하더라도 그 값을 변환해서 원래의 패스워드를 알 수는 없다.
   - SHA 알고리즘에는 여러 가지가 있는데 (SHA-0, SHA-1, ...) 현재 SHA-0과 SHA-1 알고리즘에 취약점이 있다는 것이 밝혀졌다.
   - 패스워드 해시에 SHA 알고리즘을 사용한다면 SHA-2나 SHA-3를 사용하라. 현재 패스워드 해시 함수의 표준은 'bcrypt'이다. (하지만 어떤 것도 완벽하지는 않다.)

## 지역 민감 해싱

- SHA는 지역 민감적이지 않다.
- 지역 민감적이란 말은 두 개의 입력 문자열이 비슷하면 출력되는 해시값도 비슷해진다는 뜻이다.
- 하지만 어떨 때는 반대로 지역 민감 해시(locality-sensitive hash) 함수가 필요할 때도 있다. Simhash를 사용한다.
- Simhash를 쓰면 문자열이 조금 바뀌었을 때 해시값도 조금만 바뀐다.

  1. 구글은 Simhash를 사용해서 크롤링할 웹 페이지가 중복되었는지 판단한다.

  2. 선생님은 Simhash를 사용해서 학생이 작문 숙제를 인터넷에서 베꼈는지 알 수 있다.

  3. Scribd 서비스는 사용자가 문서나 책을 업로드해서 다른 사람들과 공유하도록 한다. 하지만 저작권이 있는 내용은 업로드하지 못하도록 한다. 이 서비스는 Simhash를 사용하여 사용자가 업로드한 내용이 해리포터 책과 같은지 살펴보고, 만약 같은 내용이라면 자동으로 업로드를 거절하도록 한다.

## 09 Diffie-Hellman algorithm(디피-헬만 알고리즘)

- 이 알고리즘은 오랫동안 제기된 다음과 같은 문제를 아주 간결한 방식으로 풀어냈다.
- **메시지를 받은 사람만 읽을 수 있도록 하려면 메세지를 어떻게 암호화해야 할까?**
- 디피-헬만 알고리즘을 사용하면 다음과 같은 두 가지 문제를 해결할 수 있다.

  1. 양쪽 모두 암호 해독 규칙을 가질 필요가 없어야 한다. 그러면 만나서 암호 해독 규칙을 공유할 필요도 없다.
  2. 암호화된 메시지는 해독하기 어려워야 한다.

- 디피-헬만 알고리즘은 **두 개의 키**를 가진다. 하나는 공개 키(public key)이고, 하나는 개인 키(private key)이다.
- 공개 키는 말 그대로 공개된다. 웹 사이트에 공개할 수도 있고, 친구에게 이메일로 보낼 수도 있고 무슨 일을 해도 상관없다. 감출 필요가 없다.
- 누군가가 당신에게 메세지를 보내고 싶을 때는 이 공개 키를 암호화를 한다.
- 다만 암호화된 메시지를 해독하기 위해서는 개인 키가 있어야 한다.
- 개인 키를 여러분만 가지고 있다면 여러분만 이 메시지를 해독할 수 있는 겁니다.
- 디피-헬만 알고리즘은 후속 알고리즘인 RSA와 함께 현재도 많이 사용되고 있다.
- 만약 암호학에 관심이 있다면 디피-헬만 알고리즘부터 시작하는 것도 좋다. 간결하면서도 이해하기 쉽기 때문이다.

## 10 Linear Programming (선형 프로그래밍)

- 선형 프로그래밍은 필자가 알고 있는 가장 멋있는 알고리즘 중 하나이다.
- 선형 프로그래밍은 **제한 조건하**에서 무언가를 최대화할 때 사용한다.

  1. 회사에서 두 종류의 상품, 즉 셔츠와 가방을 만들고 있다. 셔츠를 만드는 데는 천 1미터와 단추 5개가 필요하고, 가방을 만드는 데는 천 2미터와 단추 2개가 필요하다. 회사에는 천 11미터와 단추 20개가 있다. 셔츠와 가방의 가격은 각각 2달러와 3달러이다. 이익을 최대화하려면 셔츠와 가방을 몇 개씩 만들어야 할까? 여기에서는 재료라는 제한 조건하에서 이익을 최대화하려고 한다.

  2. 정치인이 받을 수 있는 표를 최대화하고 싶다. 조사 결과를 보면 샌프란시스코에서는 1시간의 노력으로 1표를, 시카고에서는 1.5시간의 노력으로 1표를 얻을 수 있다. 샌프란시스코에는 최소 500명, 시카고에는 최소 300명의 선거 운동원이 필요하다. 투표까지 50일이 남았는데 샌프란시스코의 선거원 일당은 2달러, 시카고는 1달러이다. 전체 예산은 1,500달러이다. 샌프란시스코와 시카고에서 얻을 수 있는 최대 표는 얼마인가? 여기에는 시간과 돈이라는 제한 조건하에서 득표수를 최대화하려고 한다.

- 선형 프로그래밍은 훨씬 더 방대한 주제이고, 그래프 문제는 선형 프로그래밍의 '특수한 경우'에 지나지 않는다.
- 선형 프로그래밍에서는 Simplex algorithm이라는 것을 쓰는데, 너무 복잡하기 때문에 이 책에서는 다루지 않는다.
- 만약 최적화에 관심이 있다면 선형 프로그래밍을 공부해 보세요.
