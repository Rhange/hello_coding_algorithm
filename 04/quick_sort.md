# Quick Sort

## 1. Divide-and-Conquer

1. 가장 간단한 경우의 기본 단계(base case)를 찾는다.
2. 주어진 문제를 작게 줄여서 기본 단계가 되도록 만드는 법을 찾아낸다.

- Recursion은 상태를 추적한다는 점을 명심하라.
- 배열을 포함하는 재귀 함수를 만들 때, base case는 보통 빈 배열이나 원소가 하나뿐인 배열이 된다. 만약 문제를 풀다 막히면 이 방법을 떠올려보라.
- 하스켈(Haskell)과 같은 함수형 프로그래밍(functional programming) 언어에는 반복문이 없다. 그러니 무조건 재귀 함수를 사용해야 한다.

## 2. Quick Sort

- 퀵 정렬은 선택 정렬보다 훨씬 빠르고 자주 사용된다.
- 퀵 정렬도 마찬가지로 분할 정복 전략이다.
- 배열에서 원소 하나를 고를 때, 이 원소를 **기준 원소(pivot)**라고 한다.
- 기준 원소를 기준으로 '작은 원소들'과 '큰 원소들'로 분류한다. 이를, **분할(partitioning)**이라고 한다.
  - 기준 원소(pivot)보다 **작은 숫자들**로 이루어진 하위 배열(sub-array)
  - 기준 원소
  - 기준 원소보다 **큰 숫자들**로 이루어진 하위 배열
- 귀납적 증명과 퀵 정렬은 매우 유사하다.
- 귀납적 증명은 분할 정복 전략과 함께 사용되기도 한다.

## 3. Remind Big O notation

- 이진 탐색, O(log n)
- 단순 탐색, O(n)
- 퀵 정렬, O(n \* log n), 퀵 정렬은 최악의 경우 O(n \* n)이 될 수도 있다.
- 선택 정렬, O(n \* n)
- 외판원 문제, O(n!)
- 병합 정렬(merge sort), O(n \* log n)

### Question

- 최악의 경우와 일반적인 경우란?
- 퀵 정렬이 평균적으로 O(n \* log n)이라면 병합 정렬은 항상 O(n \_ log n)인가? 그럼 왜 병합 정렬을 쓰지 않는가? 훨씬 빠른데?

- c \* n, c is constant
- 기본적으로 상수 값은 큰 차이를 주지 않지만, 퀵 정렬과 병합 정렬은 상수 때문에 차이가 발생한다.
- 퀵 정렬이 병합 정렬보다 더 작은 상수를 가지므로, 실행 시간이 둘 다 O(n \* log n)으로 동일하다면 퀵 정렬이 더 빠르다.
- 퀵 정렬을 사용할 때 '최악의 경우'보다는 '일반적인 경우'가 훨씬 많이 발생하기 때문에 현실에서는 퀵 정렬이 더 빠르다.

#### 평균적인 경우와 최악의 경우

- 최악의 경우는 작은 원소와 큰 원소로 나눠지지 않고 하나로 계속 몰리는 상황에서 나타난다. 예를 들어 정렬된 배열인데 맨 앞의 숫자를 pivot으로 계속 선택한다면 8개 원소의 배열이라면 8개의 call stack이 쌓이게 된다. 즉, O(n)
- 평균적인 경우(일반적인 경우), 원소 전체 배열에서 무작위로 선택하면 평균적으로 작은 하위 배열과 큰 하위 배열로 나뉘어지고, call stack 수는 log n이 된다.
- 각 stack 마다 비교해야 하는 수는 O(n)으로 같으므로 최악의 경우는 O(n) \* O(n) = O(n \* n), 일반적인 경우는 O(n) \* O(log n) = O(n \* log n)의 시간을 가진다.

## 정리

- 분할 정복(divide-and-conquer)은 문제를 더 작은 조각으로 나누어 푼다. 만약 리스트에 분할 정복을 적용한다면 기본 단계는 원소가 없는 빈 배열이거나 하나의 원소만 가진 배열이 된다.
- 퀵 정렬(quick sort)을 구현하려면 기준 원소를 무작위로 선택한다. 퀵 정렬의 평균적인 실행 시간은 O(n \* log n)이다.
- Big O notation에서 가끔씩 상수(constant)가 중요해질 때도 있다. 퀵 정렬이 병합 정렬보다 빠른 이유도 상수 때문이다.
- 단순 탐색과 이진 탐색을 비교할 때는 상수항이 전혀 문제가 되지 않는다. 왜냐하면 리스트가 길어지면 O(log n)이 O(n)보다 훨씬 빨라지기 때문이다.

## 연습문제

1. 배열의 모든 원소의 값 출력

   - O(n)

2. 배열의 모든 원소의 값을 두 배로 늘리기

   - O(n)

3. 배열의 첫 번째 원소의 값만 두 배로 만들기

   - O(log n): X
   - O(1): O, arr[0] \* 2

4. 배열의 모든 원소 조합에 대해 곱셈표 만들기

   - O(n \* n)
